---
layout: default
title: Simulating the Law of Large Numbers 
---

<style>
/* Stili ottimizzati: Aumento dell'altezza e dello spazio sotto i grafici */
.chart-container {
    display: flex;
    flex-direction: row; 
    align-items: stretch;
    gap: 30px; 
    margin-top: 20px;
    height: 600px; /* **AUMENTATO L'ALTEZZA** a 600px per dare più spazio verticale al grafico principale e ai titoli degli assi */
    max-width: 100%;
    margin-bottom: 70px; /* **AUMENTATO IL MARGINE INFERIORE** a 70px per separare bene l'asse X dal testo */
}

.main-chart {
    flex-grow: 3; 
    min-width: 55%; 
    max-width: 70%; 
    height: 100%;
}

.side-histogram {
    flex-grow: 1; 
    min-width: 250px; 
    max-width: 35%; 
    height: 100%;
}

/* Ensure the canvas elements fill their parent containers */
.main-chart canvas, .side-histogram canvas {
    width: 100% !important;
    height: 100% !important;
}

/* Style for the parameter controls */
.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.controls-grid label {
    display: block;
    font-weight: bold;
    margin-bottom: 5px;
}
</style>

<h2>Understanding the Law of Large Numbers (LLN)</h2>
<p>
The **Law of Large Numbers (LLN)** is a fundamental theorem in probability that describes the result of performing the same experiment a large number of times. It states that as the number of trials ($n$) increases, the **average of the results** obtained from the trials will converge towards the **expected value** or the theoretical probability of the event.
</p>

<p>
In the context of a **Bernoulli Trial** (like a coin flip), the LLN guarantees that the **relative frequency** of successes, $f(n) = \frac{\text{Number of Successes}}{\text{Total Trials}}$, will get closer and closer to the true probability of success ($p$) as the number of trials ($n$) grows large.
</p>

<p>
$$ \bar{X}_n \xrightarrow{p} \mu \quad \text{as} \quad n \to \infty $$
</p>
<p>
where $\bar{X}_n$ is the sample mean (the relative frequency $f(n)$) and $\mu$ is the expected value (the true probability $p$).
</p>

<hr>

<h2>Interactive LLN Simulation: Convergence of Relative Frequency</h2>
<p>
This simulation illustrates the LLN using a set of **Bernoulli Trials** (e.g., flipping a weighted coin).
We plot **multiple trajectories ($m$)** of the relative frequency $f(n)$ over a sequence of trials ($n$) to see how they all stabilize around the true probability ($p$).
</p>

<div class="controls-grid">
    <div>
        <label for="probInput">True Probability of Success (p):</label>
        <input type="number" id="probInput" value="0.5" min="0.01" max="0.99" step="0.01" style="width: 100%;">
        <small>Set the theoretical probability (e.g., 0.5 for a fair coin).</small>
    </div>
    <div>
        <label for="trajectoriesInput">Number of Trajectories (m):</label>
        <input type="number" id="trajectoriesInput" value="10" min="1" max="50" step="1" style="width: 100%;">
        <small>How many different simulations to run simultaneously.</small>
    </div>
    <div>
        <label for="trialsInput">Max Number of Trials (n):</label>
        <input type="number" id="trialsInput" value="1000" min="100" max="10000" step="100" style="width: 100%;">
        <small>The maximum length of each simulation.</small>
    </div>
    <div style="grid-column: span 1 / auto;">
        <button id="runSimulationButton" style="width: 100%; padding: 10px; font-weight: bold;">Run Simulation</button>
    </div>
</div>

<hr>

<h2>Visualization</h2>
<div class="chart-container">
    <div class="main-chart">
        <h4>Multiple Trajectories of Relative Frequency, $f(n)$</h4>
        <canvas id="llnChart"></canvas>
    </div>
    <div class="side-histogram">
        <h4>Empirical Distribution of $f(n)$ for large $n$</h4>
        <canvas id="histogramChart"></canvas>
    </div>
</div>

<p>
**Main Chart:** Each colored line represents a single trajectory ($m$) of the relative frequency ($f(n)$). As the number of trials ($n$) on the X-axis increases, all trajectories quickly cluster and converge towards the **True Probability (p)**, shown by the dashed line. The initial fluctuation for small $n$ highlights the effect of randomness.
</p>

<p>
**Side Histogram:** This chart shows the **empirical distribution** of the relative frequency, $f(n)$, taken across all $m$ trajectories at the **maximum number of trials ($n$)**. For a large $n$, this distribution becomes extremely narrow and tall, centering directly on the true probability $p$. This visually demonstrates that for a large number of trials, the probability of the relative frequency being far from $p$ is almost zero.
</p>

<hr>

<h2>Implementation Code (JavaScript)</h2>
<p>
The simulation is implemented using **Chart.js** for the visualization. The code simulates a series of Bernoulli trials and updates the charts to show the convergence effect.
</p>

<button id="toggleCodeBtn" style="margin-bottom: 10px;">Show Simulation Code</button>
<div id="simulationCodeBlock" style="display: none; margin-bottom: 20px;">
    <h4>Simulation Function (`simulateLLN`)</h4>
    <pre><code class="language-javascript">
// Function to simulate 'm' trajectories of 'n' trials
function simulateLLN(p, m, n) {
    const data = [];
    const finalFrequencies = [];

    for (let i = 0; i < m; i++) {
        let successes = 0;
        const trajectory = [];

        for (let j = 1; j <= n; j++) {
            successes += bernoulliTrial(p);
            // Relative frequency f(n)
            const f_n = successes / j;
            trajectory.push({ x: j, y: f_n });
        }
        data.push(trajectory);
        finalFrequencies.push(trajectory[trajectory.length - 1].y);
    }
    return { data, finalFrequencies };
}
    </code></pre>
</div>

<button id="toggleHistogramFuncBtn" style="margin-bottom: 10px;">Show getHistogramData function</button>
<div id="histogramCodeBlock" style="display: none; margin-bottom: 20px;">
    <h4>Histogram Data Calculation Function (`getHistogramData`)</h4>
    <pre><code class="language-javascript">
function getHistogramData(data, p) {
    // Define bins around the true probability p
    const numBins = 15;
    const range = 0.05; // e.g., p ± 0.05
    const minVal = Math.max(0, p - range);
    const maxVal = Math.min(1, p + range);
    const binWidth = (maxVal - minVal) / numBins;
    
    const bins = new Array(numBins).fill(0);
    const labels = [];

    for (let i = 0; i < numBins; i++) {
        labels.push((minVal + i * binWidth).toFixed(3));
    }

    // Populate bins: data contains the final f(n) values from all m trajectories
    data.forEach(freq => {
        if (freq >= minVal && freq < maxVal) {
            let binIndex = Math.floor((freq - minVal) / binWidth);
            // Handle max boundary case
            if (binIndex === numBins) binIndex = numBins - 1;
            bins[binIndex]++;
        }
    });

    return { bins, labels };
}
    </code></pre>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// Function to perform a single Bernoulli trial (success = 1, failure = 0)
function bernoulliTrial(p) {
    return Math.random() < p ? 1 : 0;
}

// Function to simulate 'm' trajectories of 'n' trials (defined in HTML code block)
function simulateLLN(p, m, n) {
    const data = [];
    const finalFrequencies = [];

    for (let i = 0; i < m; i++) {
        let successes = 0;
        const trajectory = [];

        for (let j = 1; j <= n; j++) {
            successes += bernoulliTrial(p);
            // Relative frequency f(n)
            const f_n = successes / j;
            trajectory.push({ x: j, y: f_n });
        }
        data.push(trajectory);
        finalFrequencies.push(trajectory[trajectory.length - 1].y);
    }
    return { data, finalFrequencies };
}

// Function to calculate histogram bins (defined in HTML code block)
function getHistogramData(data, p) {
    // Define bins around the true probability p
    const numBins = 15;
    const range = 0.05; // e.g., p ± 0.05
    const minVal = Math.max(0, p - range);
    const maxVal = Math.min(1, p + range);
    const binWidth = (maxVal - minVal) / numBins;
    
    const bins = new Array(numBins).fill(0);
    const labels = [];

    for (let i = 0; i < numBins; i++) {
        labels.push((minVal + i * binWidth).toFixed(3));
    }

    // Populate bins
    data.forEach(freq => {
        if (freq >= minVal && freq < maxVal) {
            let binIndex = Math.floor((freq - minVal) / binWidth);
            // Handle max boundary case
            if (binIndex === numBins) binIndex = numBins - 1;
            bins[binIndex]++;
        }
    });

    return { bins, labels };
}

// Global chart instances
let llnChartInstance = null;
let histogramChartInstance = null;

function updateCharts(p, m, n) {
    const { data, finalFrequencies } = simulateLLN(p, m, n);

    // Color palette for trajectories (to make them distinct)
    const colors = [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
        '#FF9F40', '#E7E9ED', '#4B77BE', '#5AD3D1', '#FFC870'
    ];
    
    const datasets = data.map((trajectory, index) => ({
        label: `Trajectory ${index + 1}`,
        data: trajectory,
        borderColor: colors[index % colors.length],
        borderWidth: 1,
        pointRadius: 0,
        fill: false,
        tension: 0 // Keep lines straight
    }));
    
    // Add the true probability line
    datasets.push({
        label: `True Probability (p = ${p})`,
        data: [{ x: 1, y: p }, { x: n, y: p }],
        borderColor: 'black',
        borderWidth: 2,
        borderDash: [5, 5],
        pointRadius: 0,
        fill: false
    });

    const llnCtx = document.getElementById('llnChart').getContext('2d');
    if (llnChartInstance) llnChartInstance.destroy();

    llnChartInstance = new Chart(llnCtx, {
        type: 'line',
        data: { datasets: datasets },
        options: {
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    title: { display: true, text: 'Number of Trials (n)' },
                    min: 1,
                    max: n
                },
                y: {
                    title: { display: true, text: 'Relative Frequency f(n)' },
                    min: 0,
                    max: 1
                }
            },
            plugins: { legend: { display: false } }
        }
    });

    // --- Side Histogram Update ---
    const { bins, labels } = getHistogramData(finalFrequencies, p);
    const histogramCtx = document.getElementById('histogramChart').getContext('2d');

    if (histogramChartInstance) histogramChartInstance.destroy();

    histogramChartInstance = new Chart(histogramCtx, {
        type: 'bar',
        data: {
            labels: labels, // Bin labels
            datasets: [{
                label: 'Count of f(n) at max n',
                data: bins,
                backgroundColor: 'rgba(75, 192, 192, 0.6)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1,
            }]
        },
        options: {
            maintainAspectRatio: false,
            indexAxis: 'y', // Vertical orientation
            scales: {
                x: {
                    title: { display: true, text: 'Count' },
                    beginAtZero: true
                },
                y: {
                    title: { display: true, text: 'f(n) Value' },
                    beginAtZero: false,
                    // Highlight the bin containing 'p'
                    ticks: {
                        callback: function(val, index) {
                            // Simplified way to check if the label is close to p for a marker
                            const labelValue = parseFloat(labels[index]);
                            // Assuming p is the midpoint of a bin for simplicity in marking
                            if (Math.abs(labelValue - p) < 0.05/15) { 
                                return 'p=' + p;
                            }
                            return labels[index];
                        }
                    }
                }
            },
            plugins: {
                legend: { display: false },
                title: { display: false }
            }
        }
    });
}

// --- Event Listeners and Initial Setup ---
document.addEventListener('DOMContentLoaded', () => {
    const runButton = document.getElementById('runSimulationButton');
    
    // Function to handle showing/hiding code blocks
    function setupCodeToggle(buttonId, blockId) {
        const button = document.getElementById(buttonId);
        const block = document.getElementById(blockId);
        if (button && block) {
            button.addEventListener('click', () => {
                const isHidden = block.style.display === 'none';
                block.style.display = isHidden ? 'block' : 'none';
                // Adjust button text based on visibility
                let funcName = blockId.includes('simulation') ? 'Simulation Code' : 'getHistogramData function';
                button.textContent = isHidden ? `Hide ${funcName}` : `Show ${funcName}`;
            });
        }
    }
    
    // Setup for both code blocks
    setupCodeToggle('toggleCodeBtn', 'simulationCodeBlock');
    setupCodeToggle('toggleHistogramFuncBtn', 'histogramCodeBlock'); // NUOVO

    // Main simulation runner
    runButton.addEventListener('click', () => {
        const p = parseFloat(document.getElementById('probInput').value);
        const m = parseInt(document.getElementById('trajectoriesInput').value, 10);
        const n = parseInt(document.getElementById('trialsInput').value, 10);

        if (isNaN(p) || p <= 0 || p <= 0.01 || p >= 0.99) {
            alert('Please enter a valid probability p between 0.01 and 0.99.');
            return;
        }
        if (isNaN(m) || m < 1) {
            alert('Please enter a valid number of trajectories m (>= 1).');
            return;
        }
        if (isNaN(n) || n < 100) {
            alert('Please enter a valid max number of trials n (>= 100).');
            return;
        }

        updateCharts(p, m, n);
    });

    // Run the simulation with default values on page load
    updateCharts(0.5, 10, 1000);
});
</script>
