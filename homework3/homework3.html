---
layout: default
title: The RSA Cipher: Encryption and Frequency Analysis
---

<h2>The RSA Cipher: An Asymmetric Cryptosystem</h2>
<p>
The <strong>RSA (Rivest–Shamir–Adleman) cipher</strong> is a public-key cryptosystem and is one of the first and most widely used systems for secure data transmission. Unlike the Caesar cipher, which uses a single key for both encryption and decryption (symmetric), RSA uses a pair of keys: a <strong>public key</strong> for encryption and a <strong>private key</strong> for decryption (asymmetric).
</p>
<p>
The security of RSA relies on the computational difficulty of factoring large integers—specifically, finding the two large prime factors of a very large composite number. However, for this exercise, we will use <strong>very small prime numbers p and q</strong> to make the computations manageable.
</p>

<hr>

<h2>RSA Key Generation Steps</h2>
<p>
The core of RSA is the generation of a key pair (e, d) and a modulus N:
</p>
<ol>
    <li><strong>Choose two distinct prime numbers, p and q</strong> (e.g., p=3, q=11).</li>
    <li><strong>Compute the modulus N</strong>:
        <p align="center">
            <code>N = p * q</code>
        </p>
    </li>
    <li><strong>Compute Euler's totient function, &phi;(N)</strong>:
        <p align="center">
            <code>phi(N) = (p - 1) * (q - 1)</code>
        </p>
    </li>
    <li><strong>Choose the public exponent e</strong> (the encryption key) such that 1 &lt; e &lt; &phi;(N) and e is <strong>coprime</strong> to &phi;(N) (i.e., gcd(e, &phi;(N)) = 1).</li>
    <li><strong>Compute the private exponent d</strong> (the decryption key) such that:
        <p align="center">
            <code>d = e^-1 mod phi(N)</code>
        </p>
        This means e &middot; d &equiv; 1 (mod &phi;(N)).
    </li>
</ol>
<p>
The <strong>Public Key</strong> is (e, N). The <strong>Private Key</strong> is d.
</p>

<hr>

<h2>Interactive RSA Cipher Tool</h2>
<p>
Use the buttons below to generate small random primes and an encryption key, or enter your own values.
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; align-items: flex-end;">
    <div style="flex: 1; min-width: 200px;">
        <label for="p_input"><strong>Prime p:</strong></label><br>
        <input type="number" id="p_input" value="3" style="width: 100%; box-sizing: border-box;">
        <button id="generatePButton" style="width: 100%; margin-top: 5px; background-color: #28a745;">Generate p</button>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="q_input"><strong>Prime q:</strong></label><br>
        <input type="number" id="q_input" value="11" style="width: 100%; box-sizing: border-box;">
        <button id="generateQButton" style="width: 100%; margin-top: 5px; background-color: #28a745;">Generate q</button>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="e_input"><strong>Public Key e:</strong></label><br>
        <input type="number" id="e_input" value="7" style="width: 100%; box-sizing: border-box;">
        <button id="generateEButton" style="width: 100%; margin-top: 5px; background-color: #ffc107; color: #333;">Generate e</button>
    </div>
</div>

<div style="margin-bottom: 15px;">
    <label for="plaintextInput"><strong>Plaintext Input (A-Z only for frequency analysis):</strong></label><br>
    <textarea id="plaintextInput" rows="4" style="width: 100%; box-sizing: border-box;" placeholder="Enter your message here..."></textarea>
</div>
<div style="margin-top: 10px;">
    <button id="encryptButton" style="background-color: #007bff;">Encrypt & Analyze RSA</button>
</div>

<div style="margin-top: 15px;">
    <label for="ciphertextOutput"><strong>Ciphertext Output (Numerical):</strong></label><br>
    <textarea id="ciphertextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>
<div style="margin-top: 15px;">
    <label for="decryptedTextOutput"><strong>Decoded Text (using d):</strong></label><br>
    <textarea id="decryptedTextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>

<p style="margin-top: 15px;">
    <strong>Calculated Modulus N:</strong> <span id="modulusN" style="font-weight: bold;">(Click the button)</span>
</p>
<p>
    <strong>Calculated Private Key d:</strong> <span id="privateD" style="font-weight: bold;">(Click the button)</span>
</p>

<hr>

<h2>Cryptanalysis: Decoding with Frequency Analysis</h2>
<p>
While RSA is secure with large prime numbers, using <strong>small, fixed primes</strong> for a letter-by-letter substitution cipher makes it vulnerable to the same type of <strong>frequency analysis</strong> used against the Caesar cipher. The frequency distribution of the ciphertext blocks can reveal the original letter distribution.
</p>
<p>
<strong>Result of Frequency Analysis:</strong>
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 15px;">
    <div style="flex: 1; min-width: 300px;">
        <h4>Plaintext Letter Distribution</h4>
        <canvas id="plaintextChart"></canvas>
    </div>
    <div style="flex: 1; min-width: 300px;">
        <h4>Ciphertext Numerical Block Distribution</h4>
        <canvas id="ciphertextChart"></canvas>
    </div>
</div>

<p style="margin-top: 15px;">
    <strong>Most Frequent Ciphertext Block (C<sub>max</sub>):</strong> <span id="mostFrequentCipher" style="font-weight: bold;">(Analysis will run after you encrypt)</span>
</p>
<p>
    <strong>Detected Plaintext Letter (M):</strong> <span id="detectedPlaintextValue" style="font-weight: bold;">(M = 4 for 'E' assumed)</span>
</p>

<hr>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- RSA Utility Functions (Essential for the Interactive Tool) ---

    // Array of small primes for random selection
    const smallPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];

    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i = i + 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    // Extended Euclidean Algorithm to find GCD and coefficients (used for modular inverse)
    function extendedGcd(a, b) {
        if (a === 0) return [b, 0, 1];
        const [gcd, x1, y1] = extendedGcd(b % a, a);
        const x = y1 - Math.floor(b / a) * x1;
        const y = x1;
        return [gcd, x, y];
    }

    // Modular Inverse (calculates d = a^-1 mod m)
    function modInverse(a, m) {
        const [gcd, x] = extendedGcd(a, m);
        if (gcd !== 1) return null; // Modular inverse does not exist
        return (x % m + m) % m;
    }

    // Modular Exponentiation: (base^exp) mod mod
    function power(base, exp, mod) {
        let res = 1;
        base %= mod;
        while (exp > 0) {
            if (exp % 2 === 1) res = (res * base) % mod;
            exp = Math.floor(exp / 2);
            base = (base * base) % mod;
        }
        return res;
    }

    // --- Key Generation Functions ---

    function generateRandomPrime(currentPrimes = []) {
        let p;
        do {
            const index = Math.floor(Math.random() * smallPrimes.length);
            p = smallPrimes[index];
        } while (currentPrimes.includes(p));
        return p;
    }

    function generateRandomE(phiN) {
        let e;
        do {
            e = Math.floor(Math.random() * (phiN - 2)) + 2; // e in range [2, phiN-1]
        } while (extendedGcd(e, phiN)[0] !== 1);
        return e;
    }

    // --- Main RSA Logic ---

    function encryptRSA(M, e, N) {
        return power(M, e, N);
    }

    function decryptRSA(C, d, N) {
        return power(C, d, N);
    }

    // Converts a message string to an array of numbers (A=0, Z=25)
    function textToNumbers(text) {
        const numbers = [];
        const cleanedText = text.toUpperCase().replace(/[^A-Z]/g, '');
        for (let i = 0; i < cleanedText.length; i++) {
            numbers.push(cleanedText.charCodeAt(i) - 65);
        }
        return numbers;
    }

    // Converts an array of numbers back to a message string
    function numbersToText(numbers) {
        let text = '';
        for (const num of numbers) {
            text += String.fromCharCode(num + 65);
        }
        return text;
    }
    
    // --- Frequency Analysis Logic ---
    
    function analyzeCiphertext(ciphertextNumbers) {
        const frequencies = {};
        let maxFreq = -1;
        let mostFrequentBlock = null;

        for (const num of ciphertextNumbers) {
            frequencies[num] = (frequencies[num] || 0) + 1;
            if (frequencies[num] > maxFreq) {
                maxFreq = frequencies[num];
                mostFrequentBlock = num;
            }
        }
        return { frequencies, mostFrequentBlock };
    }

    // --- Chart Functions ---
    
    let plaintextChartInstance = null;
    let ciphertextChartInstance = null;

    function calculateLetterFrequency(text) {
        const frequencies = new Array(26).fill(0);
        const cleanedText = text.toUpperCase().replace(/[^A-Z]/g, '');
        for (let i = 0; i < cleanedText.length; i++) {
            frequencies[cleanedText.charCodeAt(i) - 65]++;
        }
        return frequencies;
    }

    function updateCharts(plaintext, ciphertextFrequencies) {
        const labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        const plaintextFreq = calculateLetterFrequency(plaintext);

        // Prepare labels and data for the ciphertext chart (based on the blocks present)
        const cipherLabels = Object.keys(ciphertextFrequencies).sort((a, b) => a - b);
        const cipherData = cipherLabels.map(label => ciphertextFrequencies[label]);

        const plaintextCtx = document.getElementById('plaintextChart').getContext('2d');
        const ciphertextCtx = document.getElementById('ciphertextChart').getContext('2d');

        if (plaintextChartInstance) plaintextChartInstance.destroy();
        if (ciphertextChartInstance) ciphertextChartInstance.destroy();

        plaintextChartInstance = new Chart(plaintextCtx, {
            type: 'bar',
            data: { 
                labels: labels, 
                datasets: [{ label: 'Frequency', data: plaintextFreq, backgroundColor: 'rgba(54, 162, 235, 0.6)' }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });

        ciphertextChartInstance = new Chart(ciphertextCtx, {
            type: 'bar',
            data: { 
                labels: cipherLabels, // Use the actual ciphertext blocks as labels
                datasets: [{ label: 'Block Frequency', data: cipherData, backgroundColor: 'rgba(255, 99, 132, 0.6)' }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });
    }

    // --- Event Listeners for Buttons ---

    document.getElementById('generatePButton').addEventListener('click', () => {
        const q = parseInt(document.getElementById('q_input').value);
        const p = generateRandomPrime(q ? [q] : []);
        document.getElementById('p_input').value
