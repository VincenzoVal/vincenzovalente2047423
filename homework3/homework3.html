---
layout: default
title: The RSA Cipher: Encryption and Frequency Analysis
---

<h2>The RSA Cipher: An Asymmetric Cryptosystem</h2>
<p>
The **RSA (Rivest–Shamir–Adleman) cipher** is a public-key cryptosystem and is one of the first and most widely used systems for secure data transmission. Unlike the Caesar cipher, which uses a single key for both encryption and decryption (symmetric), RSA uses a pair of keys: a **public key** for encryption and a **private key** for decryption (asymmetric).
</p>
<p>
The security of RSA relies on the computational difficulty of factoring large integers—specifically, finding the two large prime factors of a very large composite number. However, for this exercise, we will use **very small prime numbers $p$ and $q$** to make the computations manageable.
</p>

---

<h2>RSA Key Generation Steps</h2>
<p>
The core of RSA is the generation of a key pair $(e, d)$ and a modulus $N$:
</p>
<ol>
    <li>**Choose two distinct prime numbers, $p$ and $q$** (e.g., $p=3, q=11$).</li>
    <li>**Compute the modulus $N$**:
        $$N = p \cdot q$$
    </li>
    <li>**Compute Euler's totient function, $\phi(N)$**:
        $$\phi(N) = (p-1) \cdot (q-1)$$
    </li>
    <li>**Choose the public exponent $e$** (the encryption key) such that $1 < e < \phi(N)$ and $e$ is **coprime** to $\phi(N)$ (i.e., $\text{gcd}(e, \phi(N)) = 1$).</li>
    <li>**Compute the private exponent $d$** (the decryption key) such that:
        $$d \equiv e^{-1} \pmod{\phi(N)}$$
        This means $e \cdot d \equiv 1 \pmod{\phi(N)}$.
    </li>
</ol>
<p>
The **Public Key** is $(e, N)$. The **Private Key** is $d$.
</p>

---

<h2>RSA Encryption and Decryption</h2>

### Encryption
<p>
To encrypt a plaintext message $M$ (where $M$ is a number representing a letter) using the public key $(e, N)$, the ciphertext $C$ is computed using modular exponentiation:
</p>
<p align="center">
    $$C = M^e \pmod{N}$$
</p>
<p>
For our assignment, each letter of the message must first be converted into a number (e.g., A=0, B=1, ..., Z=25).
</p>

### Decryption
<p>
To recover the original plaintext message $M$ from the ciphertext $C$, the private key $d$ is used. As defined by the professor, the decryption process is:
</p>
<p align="center">
    $$M = C^d \pmod{N}$$
</p>
<p>
This formula is derived from the properties of modular arithmetic and **Euler's Theorem**.
</p>

<p>
**Mathematical Proof for Decryption:**
</p>
<p>
We start from the definition of encryption: $C = M^e \pmod{N}$.
</p>
<p>
By raising both sides to the power of the decryption key $d$:
<p align="center">
    $$C^d = (M^e)^d \pmod{N}$$
    $$C^d = M^{e \cdot d} \pmod{N}$$
</p>
The decryption key $d$ is chosen such that $e \cdot d \equiv 1 \pmod{\phi(N)}$, meaning that:
<p align="center">
    $$e \cdot d = 1 + k \cdot \phi(N) \quad \text{for some integer } k$$
</p>
Substituting this back into the equation:
<p align="center">
    $$C^d = M^{1 + k \cdot \phi(N)} \pmod{N}$$
    $$C^d = M^1 \cdot M^{k \cdot \phi(N)} \pmod{N}$$
    $$C^d = M \cdot (M^{\phi(N)})^k \pmod{N}$$
</p>
**Euler's Theorem** states that $M^{\phi(N)} \equiv 1 \pmod{N}$ (if $M$ and $N$ are coprime).
Therefore, we can simplify the expression:
<p align="center">
    $$(M^{\phi(N)})^k \equiv 1^k \equiv 1 \pmod{N}$$
</p>
This leads to the final decoding formula:
<p align="center">
    $$C^d \equiv M \cdot 1 \pmod{N}$$
    $$M = C^d \pmod{N}$$
</p>

---

<h2>Interactive RSA Cipher Tool</h2>
<p>
Enter your plaintext message and the parameters ($p, q, e$) for the small RSA key generation. The tool will then encrypt the message, and an attempt will be made to decode the ciphertext by analyzing the language's alphabet distribution.
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px;">
    <div style="flex: 1; min-width: 200px;">
        <label for="p_input"><strong>Prime $p$ (e.g., 3):</strong></label><br>
        <input type="number" id="p_input" value="3" style="width: 100%; box-sizing: border-box;">
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="q_input"><strong>Prime $q$ (e.g., 11):</strong></label><br>
        <input type="number" id="q_input" value="11" style="width: 100%; box-sizing: border-box;">
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="e_input"><strong>Public Key $e$ (e.g., 7):</strong></label><br>
        <input type="number" id="e_input" value="7" style="width: 100%; box-sizing: border-box;">
    </div>
</div>

<div style="margin-bottom: 15px;">
    <label for="plaintextInput"><strong>Plaintext Input:</strong></label><br>
    <textarea id="plaintextInput" rows="4" style="width: 100%; box-sizing: border-box;" placeholder="Enter your message here..."></textarea>
</div>
<div style="margin-top: 10px;">
    <button id="encryptButton">Encrypt & Analyze RSA</button>
</div>

<div style="margin-top: 15px;">
    <label for="ciphertextOutput"><strong>Ciphertext Output (Numerical):</strong></label><br>
    <textarea id="ciphertextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>
<div style="margin-top: 15px;">
    <label for="decryptedTextOutput"><strong>Decoded Text (using $d$):</strong></label><br>
    <textarea id="decryptedTextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>

<p style="margin-top: 15px;">
    <strong>Calculated Modulus $N$:</strong> <span id="modulusN" style="font-weight: bold;">(Click the button)</span>
</p>
<p>
    <strong>Calculated Private Key $d$:</strong> <span id="privateD" style="font-weight: bold;">(Click the button)</span>
</p>

---

<h2>Cryptanalysis: Decoding with Frequency Analysis</h2>
<p>
While RSA is secure with large prime numbers, using **small, fixed primes** for a letter-by-letter substitution cipher makes it vulnerable to the same type of **frequency analysis** used against the Caesar cipher. In a simple letter-to-number-to-ciphertext scheme, the most frequent letter in the plaintext (e.g., 'E' in English) will always map to the same ciphertext block.
</p>
<p>
By computing the frequency of each ciphertext block and matching the most common one to the expected most common letter in the language, it's theoretically possible to determine the original letter. This breaks the cipher without knowing the private key $d$.
</p>
<p>
**Algorithm for Cryptanalysis:**
</p>
<ol>
    <li>**Calculate the frequency** of each unique ciphertext number/block.</li>
    <li>**Find the most frequent** ciphertext number, $C_{\text{max}}$.</li>
    <li>**Assume this $C_{\text{max}}$ corresponds to the most frequent letter/number** in the plaintext language (e.g., 'E' $\rightarrow$ $M=4$ for English).</li>
    <li>**Solve for the private key $d$** (or the public key $e$, then $d$) using the relationship:
        $$M = C^d \pmod{N}$$
        This step requires finding a number $d$ such that $4 \equiv C_{\text{max}}^d \pmod{N}$. This search can be optimized.
    </li>
    <li>Once $d$ is found (or inferred from the shift's relationship to $e$), decrypt the entire message.</li>
</ol>
<p>
The charts below are intended to visualize this vulnerability by showing the distribution of the original letters and the resulting numerical ciphertext blocks.
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 15px;">
    <div style="flex: 1; min-width: 300px;">
        <h4>Plaintext Letter Distribution</h4>
        <canvas id="plaintextChart"></canvas>
    </div>
    <div style="flex: 1; min-width: 300px;">
        <h4>Ciphertext Numerical Block Distribution</h4>
        <canvas id="ciphertextChart"></canvas>
    </div>
</div>

<p style="margin-top: 15px;">
    <strong>Detected Plaintext Value for $C_{\text{max}}$:</strong> <span id="detectedPlaintextValue" style="font-weight: bold;">(Analysis will run after you encrypt)</span>
</p>

---
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
// Placeholder for all necessary JavaScript functions (RSA logic, GCD, Modular Inverse, Frequency Analysis, Chart updates)
// The actual functions are OMITTED as requested.

document.addEventListener('DOMContentLoaded', () => {
    // Placeholder chart instances
    let plaintextChartInstance = null;
    let ciphertextChartInstance = null;

    // Placeholder functions (will not execute actual RSA logic without implementation)
    function runRSACipher() {
        const p = parseInt(document.getElementById('p_input').value);
        const q = parseInt(document.getElementById('q_input').value);
        const e = parseInt(document.getElementById('e_input').value);
        const plaintext = document.getElementById('plaintextInput').value;

        if (!p || !q || !e || !plaintext) {
            alert("Please enter all parameters (p, q, e) and the plaintext.");
            return;
        }

        // --- Placeholder Logic ---
        const N = p * q;
        // In a real implementation: calculate phi(N), d, encrypt, decrypt, and perform frequency analysis.
        document.getElementById('modulusN').textContent = N;
        document.getElementById('privateD').textContent = '...'; // Placeholder for d
        document.getElementById('ciphertextOutput').value = 'Ciphertext will appear here...';
        document.getElementById('decryptedTextOutput').value = 'Decoded text will appear here...';
        document.getElementById('detectedPlaintextValue').textContent = '...';
        // --- End Placeholder Logic ---

        // Placeholder for chart update
        updateCharts(plaintext, 'Placeholder Ciphertext'); 
    }

    document.getElementById('encryptButton').addEventListener('click', runRSACipher);

    function calculateFrequency(text) {
        // Placeholder for letter frequency calculation
        const frequencies = new Array(26).fill(0).map((_, i) => Math.floor(Math.random() * 5)); 
        return frequencies;
    }

    function updateCharts(plaintext, ciphertext) {
        const labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        const plaintextFreq = calculateFrequency(plaintext);
        // The 'ciphertext' frequency would need to be the frequency of the numerical blocks
        const ciphertextFreq = calculateFrequency(ciphertext); 

        const plaintextCtx = document.getElementById('plaintextChart').getContext('2d');
        const ciphertextCtx = document.getElementById('ciphertextChart').getContext('2d');

        if (plaintextChartInstance) plaintextChartInstance.destroy();
        if (ciphertextChartInstance) ciphertextChartInstance.destroy();

        // Chart setup placeholders
        plaintextChartInstance = new Chart(plaintextCtx, {
            type: 'bar',
            data: { labels: labels, datasets: [{ label: 'Frequency', data: plaintextFreq, backgroundColor: 'rgba(54, 162, 235, 0.6)' }] },
            options: { scales: { y: { beginAtZero: true, suggestedMax: 5 } } }
        });

        ciphertextChartInstance = new Chart(ciphertextCtx, {
            type: 'bar',
            data: { labels: labels, datasets: [{ label: 'Frequency', data: ciphertextFreq, backgroundColor: 'rgba(255, 99, 132, 0.6)' }] },
            options: { scales: { y: { beginAtZero: true, suggestedMax: 5 } } }
        });
    }

});
</script>
