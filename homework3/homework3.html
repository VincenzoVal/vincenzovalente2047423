---
layout: default
title: The RSA Cipher, Encryption and Frequency Analysis
---

<h2>The RSA Cipher: An Asymmetric Cryptosystem</h2>
<p>
The <strong>RSA (Rivest–Shamir–Adleman) cipher</strong> is a public-key cryptosystem and is one of the first and most widely used systems for secure data transmission. Unlike the Caesar cipher, which uses a single key for both encryption and decryption (symmetric), RSA uses a pair of keys: a <strong>public key</strong> for encryption and a <strong>private key</strong> for decryption (asymmetric).
</p>
<p>
The security of RSA relies on the computational difficulty of factoring large integers—specifically, finding the two large prime factors of a very large composite number. However, for this exercise, we will use <strong>very small prime numbers p and q</strong> to make the computations manageable.
</p>

<hr>

<h2>RSA Key Generation Steps</h2>
<p>
The core of RSA is the generation of a key pair (e, d) and a modulus N:
</p>
<ol>
    <li><strong>Choose two distinct prime numbers, p and q</strong> (e.g., p=13, q=17). Nota: Per includere spazi, N deve essere maggiore di 26.</li>
    <li><strong>Compute the modulus N</strong>:
        <p align="center">
            <code>N = p * q</code>
        </p>
    </li>
    <li><strong>Compute Euler's totient function, &phi;(N)</strong>:
        <p align="center">
            <code>phi(N) = (p - 1) * (q - 1)</code>
        </p>
    </li>
    <li><strong>Choose the public exponent e</strong> (the encryption key) such that 1 &lt; e &lt; &phi;(N) and e is <strong>coprime</strong> to &phi;(N) (i.e., gcd(e, &phi;(N)) = 1).</li>
    <li><strong>Compute the private exponent d</strong> (the decryption key) such that:
        <p align="center">
            <code>d = e^-1 mod phi(N)</code>
        </p>
        This means e &middot; d &equiv; 1 (mod &phi;(N)).
    </li>
</ol>
<p>
The <strong>Public Key</strong> is (e, N). The <strong>Private Key</strong> is d.
</p>

<hr>

<h2>Interactive RSA Cipher Tool</h2>
<p>
Use the buttons below to generate small random primes and an encryption key, or enter your own values.
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; align-items: flex-end;">
    <div style="flex: 1; min-width: 200px;">
        <label for="p_input"><strong>Prime p:</strong></label><br>
        <input type="number" id="p_input" value="13" style="width: 100%; box-sizing: border-box;">
        <button id="generatePButton" style="width: 100%; margin-top: 5px;">Generate p</button>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="q_input"><strong>Prime q:</strong></label><br>
        <input type="number" id="q_input" value="17" style="width: 100%; box-sizing: border-box;">
        <button id="generateQButton" style="width: 100%; margin-top: 5px;">Generate q</button>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="e_input"><strong>Public Key e:</strong></label><br>
        <input type="number" id="e_input" value="11" style="width: 100%; box-sizing: border-box;">
        <button id="generateEButton" style="width: 100%; margin-top: 5px;">Generate e</button>
    </div>
</div>

<div style="margin-bottom: 15px;">
    <label for="plaintextInput"><strong>Plaintext Input (A-Z, a-z, and spaces):</strong></label><br>
    <textarea id="plaintextInput" rows="4" style="width: 100%; box-sizing: border-box;" placeholder="Enter your message here..."></textarea>
</div>
<div style="margin-top: 10px;">
    <button id="encryptButton">Encrypt & Analyze RSA</button>
</div>

<div style="margin-top: 15px;">
    <label for="ciphertextOutput"><strong>Ciphertext Output (Numerical Blocks):</strong></label><br>
    <textarea id="ciphertextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>
<div style="margin-top: 15px;">
    <label for="decryptedTextOutput"><strong>Decoded Text (using d):</strong></label><br>
    <textarea id="decryptedTextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>

<p style="margin-top: 15px;">
    <strong>Calculated Modulus N:</strong> <span id="modulusN" style="font-weight: bold;">(Click the button)</span>
</p>
<p>
    <strong>Calculated Private Key d:</strong> <span id="privateD" style="font-weight: bold;">(Click the button)</span>
</p>

<hr>

<h2>Cryptanalysis: Decoding with Frequency Analysis</h2>
<p>
This section attempts to break the cipher by identifying the most frequent ciphertext block (C<sub>max</sub>) and assuming it corresponds to the most frequent letter ('E', M=4). This assumption is then used to find the private key and decrypt the message without knowing the original key $d$.
</p>
<p>
**Nota:** L'analisi di frequenza è eseguita solo sulle lettere (A-Z), ignorando gli spazi per un confronto statistico corretto.
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 15px;">
    <div style="flex: 1; min-width: 300px;">
        <h4>Plaintext Letter Distribution</h4>
        <canvas id="plaintextChart"></canvas>
    </div>
    <div style="flex: 1; min-width: 300px;">
        <h4>Ciphertext Numerical Block Distribution</h4>
        <canvas id="ciphertextChart"></canvas>
    </div>
</div>

<p style="margin-top: 15px;">
    <strong>1. Most Frequent Ciphertext Block (C<sub>max</sub>):</strong> <span id="mostFrequentCipher" style="font-weight: bold;">(Analysis will run after you encrypt)</span>
</p>
<p>
    <strong>2. Inferred Private Key (d<sub>attack</sub>) from C<sub>max</sub>:</strong> <span id="inferredKeyD" style="font-weight: bold;">(d = ?)</span>
</p>
<div style="margin-top: 15px;">
    <label for="decryptedTextAttackOutput"><strong>3. Decoded Text (using d<sub>attack</sub>):</strong></label><br>
    <textarea id="decryptedTextAttackOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>

<hr>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- Global Configuration ---
    const smallPrimes = [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];
    const BLOCK_SPACE = 26; // Numeric block for space
    const M_ASSUMED = 4;    // Numerical value for 'E' (A=0, E=4)

    let originalChars = []; // Global array to preserve case and non-alpha chars

    // --- RSA Utility Functions ---

    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i = i + 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    function extendedGcd(a, b) {
        if (a === 0) return [b, 0, 1];
        const [gcd, x1, y1] = extendedGcd(b % a, a);
        const x = y1 - Math.floor(b / a) * x1;
        const y = x1;
        return [gcd, x, y];
    }

    function modInverse(a, m) {
        const [gcd, x] = extendedGcd(a, m);
        if (gcd !== 1) return null;
        return (x % m + m) % m;
    }

    function power(base, exp, mod) {
        let res = 1n;
        let baseBig = BigInt(base) % BigInt(mod);
        let expBig = BigInt(exp);
        let modBig = BigInt(mod);

        while (expBig > 0n) {
            if (expBig % 2n === 1n) res = (res * baseBig) % modBig;
            expBig = expBig / 2n;
            baseBig = (baseBig * baseBig) % modBig;
        }
        return Number(res);
    }

    // --- Text Conversion Logic ---

    function textToNumbers(text) {
        const numbers = [];
        originalChars = [];
        
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            
            if (char === ' ') {
                numbers.push(BLOCK_SPACE);
                originalChars.push(char);
            } else if (char.match(/[a-zA-Z]/)) {
                numbers.push(char.toUpperCase().charCodeAt(0) - 65);
                originalChars.push(char); // Save original case
            } 
            // Ignore other non-alpha, non-space characters
        }
        return numbers;
    }

    function numbersToText(decryptedNumbers) {
        let text = '';
        if (decryptedNumbers.length !== originalChars.length) {
            return "Error: Decryption length mismatch.";
        }
        
        for (let i = 0; i < decryptedNumbers.length; i++) {
            const num = decryptedNumbers[i];
            const originalChar = originalChars[i];

            if (num === BLOCK_SPACE) {
                text += ' ';
            } else if (num >= 0 && num <= 25) {
                const baseChar = String.fromCharCode(num + 65);
                
                // Preserve original case
                if (originalChar === originalChar.toLowerCase() && originalChar !== originalChar.toUpperCase()) {
                    text += baseChar.toLowerCase();
                } else {
                    text += baseChar;
                }
            } else {
                text += '[' + num + ']'; 
            }
        }
        return text;
    }
    
    // --- Frequency Analysis & Cryptanalysis Logic (New) ---

    function analyzeCiphertext(ciphertextNumbers, plaintextNumbers) {
        const frequencies = {};
        let maxFreq = -1;
        let mostFrequentBlock = null;

        for (let i = 0; i < ciphertextNumbers.length; i++) {
            const num = ciphertextNumbers[i];
            const plaintextNum = plaintextNumbers[i];
            
            // Only analyze letter frequencies (0-25)
            if (plaintextNum >= 0 && plaintextNum <= 25) {
                frequencies[num] = (frequencies[num] || 0) + 1;
                
                if (frequencies[num] > maxFreq) {
                    maxFreq = frequencies[num];
                    mostFrequentBlock = num;
                }
            }
        }
        return { frequencies, mostFrequentBlock };
    }

    // Function to find the private key 'd' for attack (d_attack)
    // This requires solving M_ASSUMED = C_max^(d_attack) mod N, which is hard (DLP).
    // For a simple academic proof of concept, we iterate 'd' up to phiN to find a match.
    function findInferredKeyD(C_max, M_assumed, N, phiN) {
        if (C_max === null || C_max === 0) return null;

        // Iterate through all possible values of d (1 to phiN - 1)
        for (let d = 1; d < phiN; d++) {
            // Test if C_max^d mod N equals M_assumed
            if (power(C_max, d, N) === M_assumed) {
                return d;
            }
        }
        return null; // Key not found
    }

    // --- Chart Functions ---
    
    let plaintextChartInstance = null;
    let ciphertextChartInstance = null;

    function calculateLetterFrequency(text) {
        const frequencies = new Array(26).fill(0);
        const cleanedText = text.toUpperCase().replace(/[^A-Z]/g, '');
        for (let i = 0; i < cleanedText.length; i++) {
            frequencies[cleanedText.charCodeAt(i) - 65]++;
        }
        return frequencies;
    }

    function updateCharts(plaintext, ciphertextFrequencies) {
        const labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        const plaintextFreq = calculateLetterFrequency(plaintext);

        const cipherLabels = Object.keys(ciphertextFrequencies).sort((a, b) => Number(a) - Number(b));
        const cipherData = cipherLabels.map(label => ciphertextFrequencies[label]);

        const plaintextCtx = document.getElementById('plaintextChart').getContext('2d');
        const ciphertextCtx = document.getElementById('ciphertextChart').getContext('2d');

        if (plaintextChartInstance) plaintextChartInstance.destroy();
        if (ciphertextChartInstance) ciphertextChartInstance.destroy();

        plaintextChartInstance = new Chart(plaintextCtx, {
            type: 'bar',
            data: { 
                labels: labels, 
                datasets: [{ label: 'Plaintext Frequency (A-Z)', data: plaintextFreq, backgroundColor: 'rgba(54, 162, 235, 0.6)' }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });

        ciphertextChartInstance = new Chart(ciphertextCtx, {
            type: 'bar',
            data: { 
                labels: cipherLabels, 
                datasets: [{ label: 'Ciphertext Block Frequency (Letters only)', data: cipherData, backgroundColor: 'rgba(255, 99, 132, 0.6)' }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });
    }

    // --- Random Generation Logic ---

    function generateRandomPrime(excludePrime = null) {
        let p;
        do {
            const index = Math.floor(Math.random() * smallPrimes.length);
            p = smallPrimes[index];
        } while (p === excludePrime);
        return p;
    }

    function generateRandomE(phiN) {
        let e;
        do {
            e = Math.floor(Math.random() * (phiN - 2)) + 2; 
        } while (extendedGcd(e, phiN)[0] !== 1);
        return e;
    }
    
    function generateEAndClick() {
        const p = parseInt(document.getElementById('p_input').value);
        const q = parseInt(document.getElementById('q_input').value);
        
        if (!isNaN(p) && !isNaN(q) && isPrime(p) && isPrime(q) && p !== q && (p*q) > BLOCK_SPACE) {
            const phiN = (p - 1) * (q - 1);
            const e = generateRandomE(phiN);
            document.getElementById('e_input').value = e;
        } else {
            document.getElementById('e_input').value = '';
        }
    }


    // --- Event Listeners for Buttons ---

    document.getElementById('generatePButton').addEventListener('click', () => {
        const q = parseInt(document.getElementById('q_input').value);
        const p = generateRandomPrime(q);
        document.getElementById('p_input').value = p;
        generateEAndClick(); 
    });

    document.getElementById('generateQButton').addEventListener('click', () => {
        const p = parseInt(document.getElementById('p_input').value);
        const q = generateRandomPrime(p);
        document.getElementById('q_input').value = q;
        generateEAndClick(); 
    });
    
    document.getElementById('generateEButton').addEventListener('click', generateEAndClick);


    document.getElementById('encryptButton').addEventListener('click', () => {
        const p = parseInt(document.getElementById('p_input').value);
        const q = parseInt(document.getElementById('q_input').value);
        const e = parseInt(document.getElementById('e_input').value);
        const plaintext = document.getElementById('plaintextInput').value;

        // --- 1. Validation and Key Derivation (Standard RSA) ---
        if (!plaintext) {
            alert("Please enter a message to encrypt.");
            return;
        }
        
        if (isNaN(p) || isNaN(q) || isNaN(e) || !isPrime(p) || !isPrime(q) || p === q) {
             alert("Error: P and Q must be distinct prime numbers, and E must be an integer.");
             return;
        }
        
        const N = p * q;
        if (N <= BLOCK_SPACE) {
             alert(`Error: N = ${N}. N must be greater than ${BLOCK_SPACE} for the alphabet (A-Z) and spaces.`);
             return;
        }

        const phiN = (p - 1) * (q - 1);
        const d = modInverse(e, phiN);

        if (d === null) {
            alert("Error: e is not coprime to phi(N). Please generate a new e.");
            return;
        }
        
        const plaintextNumbers = textToNumbers(plaintext);
        if (plaintextNumbers.some(M => M >= N)) {
             alert(`Error: Plaintext block value must be less than N (${N}). Your message contains unsupported characters.`);
             return;
        }

        // --- 2. Encryption and Decryption (Standard RSA) ---
        const ciphertextNumbers = plaintextNumbers.map(M => power(M, e, N));
        const decryptedNumbers = ciphertextNumbers.map(C => power(C, d, N));
        const decryptedText = numbersToText(decryptedNumbers);

        // Update Standard RSA UI
        document.getElementById('modulusN').textContent = N;
        document.getElementById('privateD').textContent = d;
        document.getElementById('ciphertextOutput').value = ciphertextNumbers.join(' ');
        document.getElementById('decryptedTextOutput').value = decryptedText;
        
        // --- 3. Cryptanalysis (Attack Simulation) ---
        const { frequencies, mostFrequentBlock } = analyzeCiphertext(ciphertextNumbers, plaintextNumbers);
        document.getElementById('mostFrequentCipher').textContent = mostFrequentBlock !== null ? mostFrequentBlock : 'N/A';
        
        let inferredKeyD = null;
        let decryptedAttackText = 'Attack Failed (Check console for details)';

        if (mostFrequentBlock !== null) {
            // Find the key d_attack such that C_max^(d_attack) mod N = M_assumed (M=4 for 'E')
            inferredKeyD = findInferredKeyD(mostFrequentBlock, M_ASSUMED, N, phiN);

            if (inferredKeyD !== null) {
                // If the key is found, decrypt the message using the inferred key
                const decryptedAttackNumbers = ciphertextNumbers.map(C => power(C, inferredKeyD, N));
                decryptedAttackText = numbersToText(decryptedAttackNumbers);
            }
        }
        
        // Update Cryptanalysis UI
        document.getElementById('inferredKeyD').textContent = inferredKeyD !== null ? inferredKeyD : 'Not found (Try a longer message)';
        document.getElementById('decryptedTextAttackOutput').value = decryptedAttackText;

        // 4. Update Charts
        updateCharts(plaintext, frequencies);
    });
});
</script>
