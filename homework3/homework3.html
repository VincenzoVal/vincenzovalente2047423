---
layout: default
title: The RSA Cipher, Encryption and Frequency Analysis
---

<h2>The RSA Cipher: An Asymmetric Cryptosystem</h2>
<p>
The <strong>RSA (Rivest–Shamir–Adleman) cipher</strong> is a public-key cryptosystem and is one of the first and most widely used systems for secure data transmission. Unlike the Caesar cipher, which uses a single key for both encryption and decryption (symmetric), RSA uses a pair of keys: a <strong>public key</strong> for encryption and a <strong>private key</strong> for decryption (asymmetric).
</p>
<p>
The security of RSA relies on the computational difficulty of factoring large integers—specifically, finding the two large prime factors of a very large composite number. However, for this exercise, we will use <strong>very small prime numbers p and q</strong> to make the computations manageable.
</p>

<hr>

<h2>RSA Key Generation Steps</h2>
<p>
The core of RSA is the generation of a key pair (e, d) and a modulus N:
</p>
<ol>
    <li><strong>Choose two distinct prime numbers, p and q</strong> (e.g., p=13, q=17). Nota: Per includere spazi, N deve essere maggiore di 26.</li>
    <li><strong>Compute the modulus N</strong>:
        <p align="center">
            <code>N = p * q</code>
        </p>
    </li>
    <li><strong>Compute Euler's totient function, &phi;(N)</strong>:
        <p align="center">
            <code>phi(N) = (p - 1) * (q - 1)</code>
        </p>
    </li>
    <li><strong>Choose the public exponent e</strong> (the encryption key) such that 1 &lt; e &lt; &phi;(N) and e is <strong>coprime</strong> to &phi;(N) (i.e., gcd(e, &phi;(N)) = 1).</li>
    <li><strong>Compute the private exponent d</strong> (the decryption key) such that:
        <p align="center">
            <code>d = e^-1 mod phi(N)</code>
        </p>
        This means e &middot; d &equiv; 1 (mod &phi;(N)).
    </li>
</ol>
<p>
The <strong>Public Key</strong> is (e, N). The <strong>Private Key</strong> is d.
</p>

<hr>

<h2>Interactive RSA Cipher Tool</h2>
<p>
Use the buttons below to generate small random primes and an encryption key, or enter your own values.
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px; align-items: flex-end;">
    <div style="flex: 1; min-width: 200px;">
        <label for="p_input"><strong>Prime p:</strong></label><br>
        <input type="number" id="p_input" value="13" style="width: 100%; box-sizing: border-box;">
        <button id="generatePButton" style="width: 100%; margin-top: 5px;">Generate p</button>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="q_input"><strong>Prime q:</strong></label><br>
        <input type="number" id="q_input" value="17" style="width: 100%; box-sizing: border-box;">
        <button id="generateQButton" style="width: 100%; margin-top: 5px;">Generate q</button>
    </div>
    <div style="flex: 1; min-width: 200px;">
        <label for="e_input"><strong>Public Key e:</strong></label><br>
        <input type="number" id="e_input" value="11" style="width: 100%; box-sizing: border-box;">
        <button id="generateEButton" style="width: 100%; margin-top: 5px;">Generate e</button>
    </div>
</div>

<div style="margin-bottom: 15px;">
    <label for="plaintextInput"><strong>Plaintext Input (A-Z, a-z, and spaces):</strong></label><br>
    <textarea id="plaintextInput" rows="4" style="width: 100%; box-sizing: border-box;" placeholder="Enter your message here..."></textarea>
</div>
<div style="margin-top: 10px;">
    <button id="encryptButton">Encrypt & Analyze RSA</button>
</div>

<div style="margin-top: 15px;">
    <label for="ciphertextOutput"><strong>Ciphertext Output (Numerical Blocks):</strong></label><br>
    <textarea id="ciphertextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>
<div style="margin-top: 15px;">
    <label for="decryptedTextOutput"><strong>Decoded Text (Capitalization and spaces preserved):</strong></label><br>
    <textarea id="decryptedTextOutput" rows="4" style="width: 100%; box-sizing: border-box;" readonly></textarea>
</div>

<p style="margin-top: 15px;">
    <strong>Calculated Modulus N:</strong> <span id="modulusN" style="font-weight: bold;">(Click the button)</span>
</p>
<p>
    <strong>Calculated Private Key d:</strong> <span id="privateD" style="font-weight: bold;">(Click the button)</span>
</p>

<hr>

<h2>Cryptanalysis: Decoding with Frequency Analysis</h2>
<p>
While RSA is secure with large prime numbers, using <strong>small, fixed primes</strong> for a letter-by-letter substitution cipher makes it vulnerable to the same type of <strong>frequency analysis</strong> used against the Caesar cipher. The frequency distribution of the ciphertext blocks can reveal the original letter distribution.
</p>
<p>
**Nota:** L'analisi di frequenza è eseguita solo sulle lettere (A-Z), ignorando gli spazi per un confronto statistico corretto.
</p>

<div style="display: flex; flex-wrap: wrap; gap: 20px; margin-top: 15px;">
    <div style="flex: 1; min-width: 300px;">
        <h4>Plaintext Letter Distribution</h4>
        <canvas id="plaintextChart"></canvas>
    </div>
    <div style="flex: 1; min-width: 300px;">
        <h4>Ciphertext Numerical Block Distribution</h4>
        <canvas id="ciphertextChart"></canvas>
    </div>
</div>

<p style="margin-top: 15px;">
    <strong>Most Frequent Ciphertext Block (C<sub>max</sub>):</strong> <span id="mostFrequentCipher" style="font-weight: bold;">(Analysis will run after you encrypt)</span>
</p>
<p>
    <strong>Detected Plaintext Letter (M):</strong> <span id="detectedPlaintextValue" style="font-weight: bold;">(M = 4 for 'E' assumed to correspond to C<sub>max</sub>)</span>
</p>

<hr>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- RSA Utility Functions ---

    // Array of small primes ensuring N > 26 (e.g., minimum N = 5*7 = 35)
    const smallPrimes = [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];
    
    // Mappatura per A-Z (0-25) e Spazio (26).
    const BLOCK_SPACE = 26;
    const ALPHABET_SIZE = 27; // 26 lettere + 1 spazio

    function isPrime(num) {
        if (num <= 1) return false;
        if (num <= 3) return true;
        if (num % 2 === 0 || num % 3 === 0) return false;
        for (let i = 5; i * i <= num; i = i + 6) {
            if (num % i === 0 || num % (i + 2) === 0) return false;
        }
        return true;
    }

    // Extended Euclidean Algorithm (returns [gcd, x, y])
    function extendedGcd(a, b) {
        if (a === 0) return [b, 0, 1];
        const [gcd, x1, y1] = extendedGcd(b % a, a);
        const x = y1 - Math.floor(b / a) * x1;
        const y = x1;
        return [gcd, x, y];
    }

    // Modular Inverse (calculates d = a^-1 mod m)
    function modInverse(a, m) {
        const [gcd, x] = extendedGcd(a, m);
        if (gcd !== 1) return null; // Inverse does not exist
        return (x % m + m) % m;
    }

    // Modular Exponentiation: (base^exp) mod mod
    function power(base, exp, mod) {
        let res = 1n;
        let baseBig = BigInt(base) % BigInt(mod);
        let expBig = BigInt(exp);
        let modBig = BigInt(mod);

        while (expBig > 0n) {
            if (expBig % 2n === 1n) res = (res * baseBig) % modBig;
            expBig = expBig / 2n;
            baseBig = (baseBig * baseBig) % modBig;
        }
        return Number(res);
    }

    // --- Core RSA and Text Conversion Logic (Updated to handle spaces and case) ---

    // Stores the original character and its case for perfect decryption fidelity
    let originalChars = []; 

    // Converts a message string to an array of numbers (A=0, Z=25, Space=26)
    function textToNumbers(text) {
        const numbers = [];
        originalChars = [];
        
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            originalChars.push(char); // Save original character
            
            if (char === ' ') {
                numbers.push(BLOCK_SPACE); // Space = 26
            } else if (char.match(/[a-zA-Z]/)) {
                // Map both 'A' and 'a' to 0, 'B' and 'b' to 1, etc.
                const uppercaseChar = char.toUpperCase();
                numbers.push(uppercaseChar.charCodeAt(0) - 65);
            } else {
                // Skip other non-alphabetic, non-space characters
                originalChars.pop(); // Remove it from the original char list
            }
        }
        return numbers;
    }

    // Converts an array of numbers back to a message string, preserving original case/spaces
    function numbersToText(decryptedNumbers) {
        let text = '';
        if (decryptedNumbers.length !== originalChars.length) {
            // Should not happen if the encryption logic is correct
            return "Error: Decryption length mismatch.";
        }
        
        for (let i = 0; i < decryptedNumbers.length; i++) {
            const num = decryptedNumbers[i];
            const originalChar = originalChars[i];

            if (num === BLOCK_SPACE) {
                text += ' ';
            } else if (num >= 0 && num <= 25) {
                // Convert number back to the base character (uppercase)
                const baseChar = String.fromCharCode(num + 65);
                
                // Preserve original case
                if (originalChar.match(/[a-z]/)) {
                    text += baseChar.toLowerCase();
                } else if (originalChar.match(/[A-Z]/)) {
                    text += baseChar;
                } else {
                    // Fallback for non-alpha original chars (should be space, handled above)
                    text += '?'; 
                }
            } else {
                // Handle blocks that decrypt outside the A-Z/Space range (should not happen)
                text += '[' + num + ']';
            }
        }
        return text;
    }

    function encryptRSA(M, e, N) {
        return power(M, e, N);
    }

    function decryptRSA(C, d, N) {
        return power(C, d, N);
    }
    
    // --- Frequency Analysis Logic (Updated to ignore spaces) ---
    
    function analyzeCiphertext(ciphertextNumbers, plaintextNumbers) {
        const frequencies = {};
        let maxFreq = -1;
        let mostFrequentBlock = null;

        for (let i = 0; i < ciphertextNumbers.length; i++) {
            const num = ciphertextNumbers[i];
            const plaintextNum = plaintextNumbers[i];
            
            // L'analisi di frequenza è pertinente solo per le lettere (0-25)
            if (plaintextNum >= 0 && plaintextNum <= 25) {
                frequencies[num] = (frequencies[num] || 0) + 1;
                
                // Trova il blocco cifrato più frequente (solo tra le lettere)
                if (frequencies[num] > maxFreq) {
                    maxFreq = frequencies[num];
                    mostFrequentBlock = num;
                }
            }
        }
        return { frequencies, mostFrequentBlock };
    }

    // --- Chart Functions (Updated to filter out spaces) ---
    
    let plaintextChartInstance = null;
    let ciphertextChartInstance = null;

    function calculateLetterFrequency(text) {
        const frequencies = new Array(26).fill(0);
        // Only count letters A-Z, ignoring case and spaces
        const cleanedText = text.toUpperCase().replace(/[^A-Z]/g, '');
        for (let i = 0; i < cleanedText.length; i++) {
            frequencies[cleanedText.charCodeAt(i) - 65]++;
        }
        return frequencies;
    }

    function updateCharts(plaintext, ciphertextFrequencies) {
        const labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        const plaintextFreq = calculateLetterFrequency(plaintext);

        // Prepare labels and data for the ciphertext chart (based only on letter blocks present)
        const cipherLabels = Object.keys(ciphertextFrequencies).sort((a, b) => Number(a) - Number(b));
        const cipherData = cipherLabels.map(label => ciphertextFrequencies[label]);

        const plaintextCtx = document.getElementById('plaintextChart').getContext('2d');
        const ciphertextCtx = document.getElementById('ciphertextChart').getContext('2d');

        if (plaintextChartInstance) plaintextChartInstance.destroy();
        if (ciphertextChartInstance) ciphertextChartInstance.destroy();

        plaintextChartInstance = new Chart(plaintextCtx, {
            type: 'bar',
            data: { 
                labels: labels, 
                datasets: [{ label: 'Plaintext Frequency (A-Z)', data: plaintextFreq, backgroundColor: 'rgba(54, 162, 235, 0.6)' }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });

        ciphertextChartInstance = new Chart(ciphertextCtx, {
            type: 'bar',
            data: { 
                labels: cipherLabels, 
                datasets: [{ label: 'Ciphertext Block Frequency (Letters only)', data: cipherData, backgroundColor: 'rgba(255, 99, 132, 0.6)' }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });
    }

    // --- Random Generation Logic ---

    function generateRandomPrime(excludePrime = null) {
        let p;
        do {
            const index = Math.floor(Math.random() * smallPrimes.length);
            p = smallPrimes[index];
        } while (p === excludePrime);
        return p;
    }

    function generateRandomE(phiN) {
        let e;
        do {
            e = Math.floor(Math.random() * (phiN - 2)) + 2; 
        } while (extendedGcd(e, phiN)[0] !== 1);
        return e;
    }
    
    function generateEAndClick() {
        const p = parseInt(document.getElementById('p_input').value);
        const q = parseInt(document.getElementById('q_input').value);
        
        // Validation check for N > 26 (necessary for A-Z + Space)
        if (!isNaN(p) && !isNaN(q) && isPrime(p) && isPrime(q) && p !== q && (p*q) > BLOCK_SPACE) {
            const phiN = (p - 1) * (q - 1);
            const e = generateRandomE(phiN);
            document.getElementById('e_input').value = e;
        } else {
            // Clear E if P or Q are invalid
            document.getElementById('e_input').value = '';
        }
    }


    // --- Event Listeners for Buttons ---

    document.getElementById('generatePButton').addEventListener('click', () => {
        const q = parseInt(document.getElementById('q_input').value);
        const p = generateRandomPrime(q);
        document.getElementById('p_input').value = p;
        generateEAndClick(); 
    });

    document.getElementById('generateQButton').addEventListener('click', () => {
        const p = parseInt(document.getElementById('p_input').value);
        const q = generateRandomPrime(p);
        document.getElementById('q_input').value = q;
        generateEAndClick(); 
    });
    
    document.getElementById('generateEButton').addEventListener('click', generateEAndClick);


    document.getElementById('encryptButton').addEventListener('click', () => {
        const p = parseInt(document.getElementById('p_input').value);
        const q = parseInt(document.getElementById('q_input').value);
        const e = parseInt(document.getElementById('e_input').value);
        const plaintext = document.getElementById('plaintextInput').value;

        if (!plaintext) {
            alert("Please enter a message to encrypt.");
            return;
        }
        
        // Final validation
        if (isNaN(p) || isNaN(q) || isNaN(e) || !isPrime(p) || !isPrime(q) || p === q) {
             alert("Error: P and Q must be distinct prime numbers, and E must be an integer.");
             return;
        }
        
        const N = p * q;
        if (N <= BLOCK_SPACE) { // N must be > 26
             alert(`Error: N = ${N}. N must be greater than ${BLOCK_SPACE} for the alphabet (A-Z) and spaces.`);
             return;
        }

        const phiN = (p - 1) * (q - 1);
        const d = modInverse(e, phiN);

        if (d === null) {
            alert("Error: e is not coprime to phi(N) or e is outside the valid range. Please generate a new e.");
            return;
        }
        
        // 1. Convert text to numbers (saves original case/spaces in global array)
        const plaintextNumbers = textToNumbers(plaintext);
        
        // Check if any plaintext number is >= N (cannot be encrypted)
        if (plaintextNumbers.some(M => M >= N)) {
             alert(`Error: Plaintext block value must be less than N (${N}). Your message contains unsupported characters.`);
             return;
        }

        // 2. Encryption
        const ciphertextNumbers = plaintextNumbers.map(M => encryptRSA(M, e, N));
        
        // 3. Decryption
        const decryptedNumbers = ciphertextNumbers.map(C => decryptRSA(C, d, N));
        const decryptedText = numbersToText(decryptedNumbers);

        // 4. Update UI
        document.getElementById('modulusN').textContent = N;
        document.getElementById('privateD').textContent = d;
        document.getElementById('ciphertextOutput').value = ciphertextNumbers.join(' ');
        document.getElementById('decryptedTextOutput').value = decryptedText;
        
        // 5. Frequency Analysis and Charts
        const { frequencies, mostFrequentBlock } = analyzeCiphertext(ciphertextNumbers, plaintextNumbers);
        document.getElementById('mostFrequentCipher').textContent = mostFrequentBlock !== null ? mostFrequentBlock : 'N/A';
        
        // The core step of the cryptanalysis exercise
        document.getElementById('detectedPlaintextValue').textContent = mostFrequentBlock !== null ? `M = 4 ('E') assumed to correspond to C=${mostFrequentBlock}` : 'N/A';

        updateCharts(plaintext, frequencies);
    });
});
</script>
